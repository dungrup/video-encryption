/* Sample implementation of decrypt engine + decoder. 
The input here is the encoded (H.264) and encrypted (AES)
packets generated by encoder.cpp 
AES decryption is inspired by https://github.com/saju/misc/blob/master/misc/openssl_aes.c */

#include "compml_video.hpp"
#include "codec.cpp"
#define BUF 500000

/**
 * Create a 256 bit key and IV using the supplied key_data. salt can be added for taste.
 **/
int aes_init(unsigned char *key_data, int key_data_len, unsigned char *salt, EVP_CIPHER_CTX *d_ctx)
{
  int i, nrounds = 5;
  unsigned char key[32], iv[32];
  
  /*
   * Gen key & IV for AES 256 CBC mode. A SHA1 digest is used to hash the supplied key material.
   * nrounds is the number of times the we hash the material. More rounds are more secure but
   * slower.
   */
  i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha1(), salt, key_data, key_data_len, nrounds, key, iv);
  if (i != 32) {
    printf("Key size is %d bits - should be 256 bits\n", i);
    return -1;
  }

  EVP_CIPHER_CTX_init(d_ctx);
  EVP_DecryptInit_ex(d_ctx, EVP_aes_256_cbc(), NULL, key, iv);
  
  return 0;
}

/*
 * Decrypt len bytes of ciphertext
 */
unsigned char *aes_decrypt(EVP_CIPHER_CTX *e, unsigned char *ciphertext, int len)
{
  /* plaintext will always be equal to or lesser than length of ciphertext*/
  int p_len = len, f_len = 0;
  unsigned char *plaintext = (unsigned char*)malloc(p_len);
  
  EVP_DecryptInit_ex(e, NULL, NULL, NULL, NULL);
  EVP_DecryptUpdate(e, plaintext, &p_len, ciphertext, len);
  EVP_DecryptFinal_ex(e, plaintext+p_len, &f_len);

  len = p_len + f_len;
  return plaintext;
}

static void decode_cloud(AVCodecContext *dec_ctx, AVFrame *frame, AVPacket *pkt,
            const char *filename = nullptr)
{
  char buf[1024];
  int ret;
  
  ret = avcodec_send_packet(dec_ctx, pkt);
  if (ret < 0)
  {
    fprintf(stderr, "Error sending a packet for decoding \n");
    exit(1);
  }

  while (ret >= 0) {
  ret = avcodec_receive_frame(dec_ctx, frame);
  if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)
    return;
  else if (ret < 0)
  {
    fprintf(stderr, "Error during decoding\n");
    exit(1);
  }

  printf("saving frame %d \n", dec_ctx->frame_number);
  fflush(stdout);
  
  snprintf(buf, sizeof(buf), "%s%07d", filename, (dec_ctx->frame_number - 1));

  pgm_save(frame->data[0], frame->linesize[0],
           frame->width, frame->height, buf);
  
 
  }
}

int main(int argc, char *argv[])
{
    int ret;
    int num_frames;
    std::string name;
    char buf[1024];
    unsigned char *img;
    AVPacket *packet;
    AVFrame *frame;
    int read_size;
    
    std::string outfilename;
    FILE *pkt_stream;
  
    unsigned char* ciphertext;
    EVP_CIPHER_CTX* de = EVP_CIPHER_CTX_new();
    unsigned int salt[] = {12345, 54321};
    unsigned char *key_data;
    int key_data_len;

    if (argc < 3)
    {
        fprintf(stderr, "Usage: %s <path to folder> <num of frames> \n"
                        "H.264 Decoder used here.\n",
                argv[0]);
        exit(0);
    }

    std::string inputPath = argv[1]; 
    num_frames = atoi(argv[2]);

    Codec decoder(false, 0, 0);

    outfilename = "./outputs/decrypt_images/";

    int size = BUF;
    img = (unsigned char *)malloc(size);
    ciphertext = (unsigned char *)malloc(size);

    packet = allocatePacket(packet);
    frame = allocateFrame(frame);

    // Decryption
    key_data = (unsigned char*)"MyKey123";
    key_data_len = strlen((char*)key_data);

    /* gen key and iv. init the cipher ctx object */
    if (aes_init(key_data, key_data_len, (unsigned char *)&salt, de)) {
        printf("Couldn't initialize AES cipher\n");
        exit(1);
    }

    for (int i = 0; i < num_frames; i++)
    {

        /* Read encoded and encrypted packets */
        snprintf(buf, sizeof(buf), "%s%07d", inputPath.c_str(), i);
        pkt_stream = fopen(buf, "r");
        
        // Read and decrypt packets
        read_size = fread(ciphertext, sizeof(unsigned char), size, pkt_stream);
        // printf("Read size: %d \n", read_size);
        img = aes_decrypt(de, ciphertext, read_size);

        // Read unencrypted packets
        // read_size = fread(img, sizeof(unsigned char), size, pkt_stream);

        do
        {
            ret = av_parser_parse2(decoder.parser, decoder.context, &(packet->data), &(packet->size),
                                       img, read_size, AV_NOPTS_VALUE, AV_NOPTS_VALUE, 0);

            if (ret < 0)
            {
                printf("Error while parsing \n");
                exit(1);
            }
    
            if (packet->size)
            {
                decode_cloud(decoder.context, frame, packet, outfilename.c_str());
            }
            
        } while (ret != 0);

        av_packet_unref(packet);

    }

    EVP_CIPHER_CTX_free(de);
    free(img);
    free(ciphertext);
    deallocateResources(packet, frame);

    return 0;
}
